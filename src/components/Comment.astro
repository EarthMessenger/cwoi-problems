---
import { pgPool } from "../db";
import { getSession } from "auth-astro/server";
import Datetime from "./Datetime.astro";

import { unified } from "unified";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import rehypeStringify from "rehype-stringify";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";

import "katex/dist/katex.css";

interface Props {
  problemId: string;
}

const session = await getSession(Astro.request);

const { problemId } = Astro.props;

const comments =
  await pgPool.sql`SELECT * FROM comments WHERE problem_id = ${problemId};`;

const remark = unified()
  .use(remarkParse)
  .use(remarkMath)
  .use(remarkRehype)
  .use(rehypeSanitize, {
    ...defaultSchema,
    attributes: {
      ...defaultSchema.attributes,
      // The `language-*` regex is allowed by default.
      code: [["className", /^language-./, "math-inline", "math-display"]],
    },
  })
  .use(rehypeKatex)
  .use(rehypeStringify);
---

<form class="comment">
  <input name="problemId" value={problemId} type="hidden" />
  <textarea name="comment"></textarea>
  <input type="submit" value="評論" />
</form>
<ul>
  {
    comments.rows.map((c) => (
      <li data-comment-id={c.id}>
        <article set:html={remark.processSync(c.content)} />
        <span>——{c.author}</span>
        <Datetime datetime={new Date(c.comment_time)} />
        {c.author == session?.user.name && (
          <button class="delete-button">刪除</button>
        )}
      </li>
    ))
  }
</ul>

<script>
  import { actions } from "astro:actions";

  const form = document.querySelectorAll(
    ".comment",
  ) as NodeListOf<HTMLFormElement>;
  form.forEach((f) => {
    f.addEventListener("submit", async (e) => {
      e.preventDefault();
      const data = new FormData(f);
      const { error } = await actions.postComment(data);
      if (!error) {
        f.querySelector("textarea").value = "";
        location.reload();
      } else console.error(error);
    });
  });

  const deleteButton = document.querySelectorAll(
    ".delete-button",
  ) as NodeListOf<HTMLButtonElement>;
  deleteButton.forEach((b) => {
    b.addEventListener("click", async (e) => {
      e.preventDefault();
      const { error } = await actions.deleteComment({
        id: parseInt(b.parentElement.dataset["commentId"]),
      });
      if (!error) location.reload();
      else console.error(error);
    });
  });
</script>
